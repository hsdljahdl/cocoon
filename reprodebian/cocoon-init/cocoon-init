#!/usr/bin/env bash
# init.sh - TDX guest initialization script
# First script to run on TDX guest startup
set -euo pipefail

# Configuration
CERT_DIR="/etc/tdx"
SPEC_RAW_DIR="/mnt/spec"
SPEC_OUT_DIR="/spec"
CERT_FILE="$CERT_DIR/cert.pem"
KEY_HASH_FILE="$CERT_DIR/key.hash"
PERSISTENT_MOUNT="/data"
RTMR3_PATH="/sys/class/misc/tdx_guest/measurements/rtmr3:sha384"
ATTESTATION_LOG="/var/log/tdx-attestation.log"

# Function to add line to attestation log and extend RTMR3
attest_log() {
  local message="$1"
  
  # Validate message contains only printable ASCII characters (no newlines, tabs, etc.)
  if [[ "$message" =~ [[:cntrl:]] ]]; then
    echo "ERR: Attestation message contains control characters (newlines, tabs, etc.)" >&2
    exit 1
  fi
  
  # Add to attestation log
  echo "$message" >> "$ATTESTATION_LOG"
  echo "Logged: $message"
  
  # Extend RTMR3 with SHA384 of the message (48 raw bytes)
  local rtmr_hash_hex=$(echo -n "$message" | sha384sum | cut -d' ' -f1)
  if ! echo -n "$message" | sha384sum | cut -d' ' -f1 | xxd -r -p > "$RTMR3_PATH"; then
    echo "ERR: Failed to extend RTMR3 with message: $message" >&2
    exit 1
  fi
  
  echo "RTMR3 extended with: $rtmr_hash_hex"
}

echo "=== TDX Guest Initialization ==="

# Init pccs
(
  systemctl stop pccs
  cd /opt/intel/sgx-dcap-pccs
  npm ci
  chown pccs .
  chown pccs config/default.json
  mkdir ssl_key 2>/dev/null || true
  openssl req -x509 -newkey rsa:2048 -keyout ssl_key/private.pem -out ssl_key/file.crt -days 3650 -nodes -subj "/CN=local-pccs/"
  chown pccs ssl_key/private.pem ssl_key/file.crt
  sed -i "/use_secure_cert/s/true/false/" /etc/sgx_default_qcnl.conf
  systemctl start pccs
)

# Create secure directories
echo "Creating secure directories..."
mkdir -p "$CERT_DIR" "$SPEC_OUT_DIR"
chmod 700 "$CERT_DIR"

# Prepare spec from raw source
echo "Preparing specification..."
if [ ! -d "$SPEC_RAW_DIR" ]; then
  echo "ERR: Raw spec directory not found: $SPEC_RAW_DIR" >&2
  exit 1
fi

if ! spec_hash=$(cocoon-prepare-spec "$SPEC_RAW_DIR" "$SPEC_OUT_DIR"); then
  echo "ERR: Failed to prepare specification" >&2
  exit 1
fi

echo "Specification prepared successfully"
echo "Spec hash: $spec_hash"

# Add spec hash to attestation log and extend RTMR3
attest_log "cocoon:spec.tree=$spec_hash"

echo "Spec preparation completed, configs will be rendered by init scripts"

# Generate sealed keys
echo "Generating sealed keys..."

# Keys to generate: "name:filename"
# Load MR_ENCLAVE (required for production)
if [ ! -f "/usr/share/cocoon/mr_enclave.txt" ]; then
  echo "ERR: MR_ENCLAVE not found: /usr/share/cocoon/mr_enclave.txt" >&2
  exit 1
fi

mr_enclave=$(cat /usr/share/cocoon/mr_enclave.txt)
echo "Using MR_ENCLAVE: $mr_enclave"

if grep -Po '\bcocoon_debug\b' /proc/cmdline; then
  echo "DEBUG MODE: All keys use same debug value"
  attest_log "cocoon:cocoon_debug"
  is_debug=true
else
  is_debug=false
fi

KEYS=("disk_encryption:sealed.key" "app:app.key")
for key_spec in "${KEYS[@]}"; do
  key_name="${key_spec%%:*}"
  key_file="$CERT_DIR/${key_spec##*:}"
  
  if [[ "$is_debug" = true ]]; then
    echo -n "cococooncococooncococooncococoon" > "$key_file"
    [[ "$key_name" = "disk_encryption" ]] && key_hash="330b40587dfe15b2a0701c5b9141b108b71474b8b3d4f719f916d944c622b91c"
  else
    key_hash=$(seal-client --mr-enclave "$mr_enclave" --output "$key_file" --key-name "$key_name") || {
      echo "ERR: Failed to generate sealed key: $key_name" >&2
      exit 1
    }
  fi
  
  chmod 400 "$key_file"
  echo "  $key_name -> $key_file"
done

# Save disk encryption key hash
echo "$key_hash" > "$KEY_HASH_FILE"
chmod 400 "$KEY_HASH_FILE"
sealed_key_file="$CERT_DIR/sealed.key"

# Add tdx_inited to attestation log and extend RTMR3
attest_log "cocoon:tdx_inited"

# Render TON config (needed for time synchronization during cert generation)
echo "Rendering TON configuration..."
cocoon-render-ton-config

# Generate certificate and key with TDX attestation (includes final RTMR3 state)
# Uses gen-cert-synced to ensure certificate time is synchronized with TON
echo "Generating TDX certificate and key with synchronized time..."
cert_base="$CERT_DIR/tdx"
if ! gen-cert-synced --tdx tdx --name "$cert_base" --force; then
  echo "ERR: Failed to generate certificate and key" >&2
  exit 1
fi

# Generate system variables for all components
echo "Generating system variables..."
mkdir -p /run
if [[ ! -f "$cert_base"_image_hash.b64 ]]; then
    echo "ERR: TDX image hash file not found: $cert_base"_image_hash.b64 >&2
    exit 1
fi

TDX_IMAGE_HASH=$(cat "$cert_base"_image_hash.b64)
APP_KEY=$(base64 < "$CERT_DIR/app.key")

{
    echo "TDX_IMAGE_HASH=$TDX_IMAGE_HASH"
    echo "TON_CONFIG_FILE=/run/spec/global.config.json"
    echo "APP_KEY=$APP_KEY"
    echo "DISK_PATH=/data"
    if [ "$is_debug" = true ]; then IS_DEBUG_INT=1; else IS_DEBUG_INT=0; fi
    echo "IS_DEBUG=$IS_DEBUG_INT"
} > /run/system.vars

echo "Generated system variables for all components:"
echo "  TDX_IMAGE_HASH: $TDX_IMAGE_HASH"

if [[ -L /dev/disk/by-id/virtio-persistent ]]; then
  if cryptsetup isLuks /dev/disk/by-id/virtio-persistent; then
    if cryptsetup luksOpen /dev/disk/by-id/virtio-persistent persistent --key-file=$sealed_key_file; then
      if mount /dev/mapper/persistent /data; then
        echo "Disk unsealed successfully."
      else
        echo "ERR: Disk unsealed successfully, but the file system failed to mount." >&2
        exit 1
      fi
    else
      echo "ERR: Disk seal key doesn't match." >&2
      exit 1
    fi
  else
    if blkid /dev/disk/by-id/virtio-persistent; then
      echo "ERR: Persistent disk is not a LUKS container." >&2
      exit 1
    else
      echo "Persistent disk is empty. Creating a seal."
      cryptsetup luksFormat -q /dev/disk/by-id/virtio-persistent --key-file=$sealed_key_file </dev/null || {
        # TODO: pick proper hash parameters
        echo "ERR: Could not format the disk as a LUKS container." >&2;
        exit 1
      }
      cryptsetup luksOpen -q /dev/disk/by-id/virtio-persistent persistent --key-file=$sealed_key_file || {
        echo "ERR: ?? Could not open the sealed container after formatting." >&2
        exit 1
      }
      mkfs.ext4 /dev/mapper/persistent || {
        echo "ERR: Could not create a filesystem in the sealed container." >&2
        exit 1
      }
      mount /dev/mapper/persistent "$PERSISTENT_MOUNT" || {
        echo "ERR: ?? Could not mount a new filesystem." >&2
        exit 1
      }
      mkdir "$PERSISTENT_MOUNT/docker"
    fi
  fi
else
  echo "ERR: No virtio device with serial 'persistent'." >&2
  exit 1
fi


# Set secure permissions on generated files
chmod 400 "$cert_base"_cert.pem "$cert_base"_key.pem 2>/dev/null || true
echo "Certificate saved to ${cert_base}_cert.pem"
echo "Private key saved to ${cert_base}_key.pem"

echo "=== TDX Guest Initialization Complete ==="
echo ""
echo "ATTESTATION INFORMATION:"
echo "  Spec hash: $spec_hash"
echo "  Key hash:  $key_hash"
echo "  RTMR3:     Extended and sealed"
echo "  Log:       $ATTESTATION_LOG"
echo ""
echo "SECURITY ARTIFACTS:"
echo "  TDX Certificate: ${cert_base}_cert.pem"
echo "  TDX Private Key: ${cert_base}_key.pem"
echo "  TDX Image Hash: $TDX_IMAGE_HASH"
echo "  Disk Encryption Key: $sealed_key_file"
echo ""
echo "PREPARED SPECIFICATION:"
echo "  Source: $SPEC_RAW_DIR"
echo "  Output: $SPEC_OUT_DIR"
echo "  Hash:   $spec_hash"
echo ""
echo "NEXT STEPS:"
echo "  1. Use certificate for TLS/attestation: ${cert_base}_cert.pem"
echo "  2. Serve application from: $SPEC_OUT_DIR"
echo "  3. Runtime configs available in: $SPEC_OUT_DIR/runtime/"
echo "  4. Persistent volume available in: $PERSISTENT_MOUNT/"
echo "  5. Verify attestation log: $ATTESTATION_LOG"
echo ""
echo "TDX guest is ready for production workloads"
