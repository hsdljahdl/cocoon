#!/usr/bin/env python3
# setup-gpu-vfio - Prepare NVIDIA GPU for TDX VFIO passthrough (idempotent)
import os
import sys
import subprocess
import shutil
import grp
import time
from pathlib import Path

DEFAULT_GPU_TOOLS_DIR = Path(__file__).parent.parent / 'gpu-admin-tools'
GPU_TOOLS_DIR = Path(os.environ.get('GPU_ADMIN_TOOLS_DIR', DEFAULT_GPU_TOOLS_DIR))
GPU_TOOLS = GPU_TOOLS_DIR / 'nvidia_gpu_tools.py'


def run(cmd, **kwargs):
    """subprocess.run wrapper that prints command"""
    #print(f'+ {" ".join(str(x) for x in cmd)}')
    return subprocess.run(cmd, **kwargs)


def check_root(operation: str = 'this operation'):
    if os.geteuid() != 0:
        sys.exit(f'ERROR: Root required for {operation}')

def require_command(cmd: str, hint: str = ''):
    """Ensure a binary exists in PATH before running it"""
    if shutil.which(cmd) is None:
        hint_msg = f' ({hint})' if hint else ''
        sys.exit(f'ERROR: Required command "{cmd}" not found{hint_msg}')


def ensure_gpu_tools():
    """Clone gpu-admin-tools if not present"""
    if GPU_TOOLS.exists():
        return

    if GPU_TOOLS_DIR.exists() and not GPU_TOOLS.exists():
        sys.exit(
            f'ERROR: GPU tools expected at {GPU_TOOLS} but missing.\n'
            'Set GPU_ADMIN_TOOLS_DIR to an existing checkout or remove the directory to re-clone.'
        )

    require_command('git', 'install git or pre-clone gpu-admin-tools and set GPU_ADMIN_TOOLS_DIR')
    print(f'Cloning NVIDIA gpu-admin-tools into {GPU_TOOLS_DIR}...')
    run([
        'git', 'clone',
        'https://github.com/nvidia/gpu-admin-tools.git',
        str(GPU_TOOLS_DIR)
    ], check=True)

def query_cc_mode(gpu_bdf: str) -> str:
    """Query current CC mode state (exits on failure)"""
    ensure_gpu_tools()
    try:
        result = run(
            ['python3', str(GPU_TOOLS), f'--gpu-bdf={gpu_bdf}', '--query-cc-mode'],
            capture_output=True, text=True, check=True
        )
    except FileNotFoundError as err:
        sys.exit(f'ERROR: Failed to execute GPU tools: {err}')
    except subprocess.CalledProcessError as err:
        output = (err.stdout or '') + (err.stderr or '')
        sys.exit(f'ERROR: Could not query CC mode for {gpu_bdf}:\n{output}'.strip())

    output = (result.stdout or '') + (result.stderr or '')
    # Match various output formats: "CC mode is on/off", "mode=on/off", "CC Mode: On/Off"
    output_lower = output.lower()
    if 'mode is on' in output_lower or 'mode=on' in output_lower or 'cc mode: on' in output_lower:
        return 'on'
    if 'mode is off' in output_lower or 'mode=off' in output_lower or 'cc mode: off' in output_lower:
        return 'off'
    sys.exit(f'ERROR: Unrecognized CC mode response for {gpu_bdf}:\n{output}'.strip())

def enable_cc_mode(gpu_bdf: str):
    """Enable CC mode on GPU (disabling PPCIe first)"""
    print(f'Enabling CC mode on {gpu_bdf}...')
    # Step 1: Disable PPCIe mode (CC and PPCIe are mutually exclusive)
    run([
        'python3', str(GPU_TOOLS),
        f'--gpu-bdf={gpu_bdf}',
        '--set-ppcie-mode=off',
        '--reset-after-ppcie-mode-switch'
    ], check=True)
    time.sleep(2)  # Wait for GPU reset to complete
    # Step 2: Enable CC mode
    run([
        'python3', str(GPU_TOOLS),
        f'--gpu-bdf={gpu_bdf}',
        '--set-cc-mode=on',
        '--reset-after-cc-mode-switch'
    ], check=True)
    time.sleep(2)  # Wait for GPU reset to complete

def resolve_vfio_group() -> str:
    """Pick a system group for VFIO device access"""
    env_group = os.environ.get('VFIO_DEVICE_GROUP')
    candidates = [env_group] if env_group else ['kvm', 'vfio', 'libvirt', 'root']

    for group in candidates:
        if not group:
            continue
        try:
            grp.getgrnam(group)
            return group
        except KeyError:
            continue

    sys.exit('ERROR: No suitable group found for VFIO devices. Set VFIO_DEVICE_GROUP to an existing group.')


def setup_udev_rules():
    """Setup udev rules for VFIO device permissions"""
    rules_path = Path('/etc/udev/rules.d/99-vfio-passthrough.rules')
    device_group = resolve_vfio_group()

    rules_content = f"""# VFIO device permissions for {device_group} group
SUBSYSTEM=="vfio", OWNER="root", GROUP="{device_group}"
SUBSYSTEM=="misc", KERNEL=="iommu", OWNER="root", GROUP="{device_group}"
SUBSYSTEM=="vfio-dev", OWNER="root", GROUP="{device_group}"
"""

    # Check if rules already exist
    if rules_path.exists():
        existing_rules = rules_path.read_text()
        if device_group in existing_rules and 'SUBSYSTEM=="vfio"' in existing_rules:
            return

    print('Setting up udev rules for VFIO permissions...')
    rules_path.write_text(rules_content)

    # Reload udev rules
    require_command('udevadm')
    run(['udevadm', 'control', '--reload-rules'], check=True)
    run(['udevadm', 'trigger'], check=True)

def get_gpu_vendor_device(gpu_bdf: str) -> tuple[str, str]:
    """Get vendor:device IDs"""
    try:
        vendor = Path(f'/sys/bus/pci/devices/{gpu_bdf}/vendor').read_text().strip()
        device = Path(f'/sys/bus/pci/devices/{gpu_bdf}/device').read_text().strip()
    except FileNotFoundError as err:
        sys.exit(f'ERROR: Unable to read PCI identifiers for {gpu_bdf}: {err}')
    return vendor, device

def detach_vfio(gpu_bdf: str):
    """Detach GPU using virsh for VFIO passthrough"""
    # Convert BDF format: 0000:ab:00.0 → pci_0000_ab_00_0
    virsh_bdf = 'pci_' + gpu_bdf.replace(':', '_').replace('.', '_')
    
    require_command('virsh', 'install libvirt-clients (or provide alternative detach tooling)')

    # Reattach first (cleanup from previous run)
    run(['virsh', 'nodedev-reattach', virsh_bdf], 
        capture_output=True, check=False)
    time.sleep(1)  # Wait for reattach to settle
    
    # Detach for VFIO
    print(f'Detaching {gpu_bdf} for VFIO passthrough...')
    run(['virsh', 'nodedev-detach', virsh_bdf], check=True)

def reattach_normal(gpu_bdf: str):
    """Reattach GPU to normal driver (nvidia)"""
    virsh_bdf = 'pci_' + gpu_bdf.replace(':', '_').replace('.', '_')
    require_command('virsh', 'install libvirt-clients (or provide alternative detach tooling)')
    print(f'Reattaching {gpu_bdf} to normal driver...')
    run(['virsh', 'nodedev-reattach', virsh_bdf], check=True)

def disable_cc_mode(gpu_bdf: str):
    """Disable CC mode on GPU (also disable PPCIe for full restore)"""
    print(f'Disabling CC and PPCIe modes on {gpu_bdf}...')
    # Step 1: Disable CC mode
    run([
        'python3', str(GPU_TOOLS),
        f'--gpu-bdf={gpu_bdf}',
        '--set-cc-mode=off',
        '--reset-after-cc-mode-switch'
    ], check=True)
    time.sleep(2)  # Wait for GPU reset to complete
    # Step 2: Disable PPCIe mode
    run([
        'python3', str(GPU_TOOLS),
        f'--gpu-bdf={gpu_bdf}',
        '--set-ppcie-mode=off',
        '--reset-after-ppcie-mode-switch'
    ], check=True)
    time.sleep(2)  # Wait for GPU reset to complete

def normalize_and_check_gpu(pci_addr: str) -> tuple[str, str]:
    """Normalize PCI address and check device exists, return (pci_addr, current_driver)"""
    # Add domain if missing
    if not pci_addr.startswith('0000:'):
        pci_addr = f'0000:{pci_addr}'
    
    # Try both .00 and .0 formats (some systems use .0, some .00)
    candidates = [pci_addr]
    if pci_addr.endswith('.00'):
        candidates.append(pci_addr[:-1])  # .00 → .0
    elif pci_addr.endswith('.0'):
        candidates.append(pci_addr + '0')  # .0 → .00
    
    for addr in candidates:
        if Path(f'/sys/bus/pci/devices/{addr}').exists():
            pci_addr = addr
            break
    else:
        sys.exit(f'ERROR: GPU not found: {pci_addr} (tried: {", ".join(candidates)})')
    
    vendor, _ = get_gpu_vendor_device(pci_addr)
    if vendor.lower() not in ('0x10de', '10de'):
        sys.exit(f'ERROR: Device {pci_addr} does not appear to be an NVIDIA GPU (vendor={vendor})')
    
    driver_path = Path(f'/sys/bus/pci/devices/{pci_addr}/driver')
    current_driver = driver_path.resolve().name if driver_path.exists() else 'none'
    
    return pci_addr, current_driver

def verify_gpu(pci_addr: str) -> bool:
    """Check if GPU is ready for VFIO passthrough (works without root)"""
    pci_addr, driver = normalize_and_check_gpu(pci_addr)
    
    ready = True
    
    # Check driver
    if driver == 'vfio-pci':
        print(f'✓ GPU {pci_addr} is bound to vfio-pci')
    else:
        print(f'✗ GPU {pci_addr} is bound to: {driver} (expected: vfio-pci)')
        ready = False
    
    # Check CC mode (may require root, so handle gracefully)
    try:
        ensure_gpu_tools()
        cc_mode = query_cc_mode(pci_addr)
        if cc_mode == 'on':
            print(f'✓ GPU {pci_addr} CC mode is enabled')
        else:
            print(f'✗ GPU {pci_addr} CC mode is: {cc_mode} (expected: on)')
            ready = False
    except (SystemExit, PermissionError, Exception):
        # CC mode check failed (likely permissions), skip it
        print(f'? GPU {pci_addr} CC mode check skipped (may require root)')
    
    if not ready:
        print(f'  Run with --setup to configure')
    
    return ready

def setup_gpu(pci_addr: str) -> None:
    """Setup GPU for TDX VFIO passthrough"""
    pci_addr, driver = normalize_and_check_gpu(pci_addr)
    
    # Need root for actual setup
    check_root('GPU configuration')
    
    print(f'Setting up GPU {pci_addr} for TDX VFIO passthrough...')
    
    # Ensure gpu-admin-tools available
    ensure_gpu_tools()
    
    # Check and enable CC mode if needed
    cc_mode = query_cc_mode(pci_addr)
    if cc_mode != 'on':
        print(f'CC mode is {cc_mode}, enabling...')
        enable_cc_mode(pci_addr)
    else:
        print(f'CC mode already enabled on {pci_addr}')
    
    # Early exit if already fully configured
    if driver == 'vfio-pci' and cc_mode == 'on':
        print(f'GPU {pci_addr} already fully setup for TDX VFIO passthrough')
        return
    
    # Setup udev rules for VFIO permissions (once for all GPUs)
    setup_udev_rules()
    
    # Detach for VFIO
    detach_vfio(pci_addr)
    
    print(f'GPU {pci_addr} ready for TDX passthrough')

def restore_gpu(pci_addr: str) -> None:
    """Restore GPU to normal usage"""
    pci_addr, driver = normalize_and_check_gpu(pci_addr)
    
    if 'nvidia' in driver:
        print(f'GPU {pci_addr} already using nvidia driver')
        return
    
    # Need root for actual restore
    check_root('GPU restore')
    
    print(f'Restoring GPU {pci_addr} to normal usage...')
    
    # Ensure gpu-admin-tools available
    ensure_gpu_tools()
    
    # Reattach to normal driver
    reattach_normal(pci_addr)
    
    # Disable CC and PPCIe modes for full restore
    disable_cc_mode(pci_addr)
    
    print(f'GPU {pci_addr} restored to normal usage')

def list_nvidia_gpus():
    """List all NVIDIA GPUs in the system"""
    try:
        result = run(['lspci', '-nn'], capture_output=True, text=True, check=True)
        gpus = []
        for line in result.stdout.splitlines():
            if '10de:' in line.lower() or 'nvidia' in line.lower():
                parts = line.split()
                if parts:
                    gpus.append(parts[0])
        return gpus
    except Exception:
        return []

def main():
    if len(sys.argv) < 2:
        # Show info about available GPUs
        gpus = list_nvidia_gpus()
        if gpus:
            print('=================================')
            print('NVIDIA GPUs found in system:')
            ensure_gpu_tools()
            for gpu in gpus:
                pci_addr = f'0000:{gpu}' if not gpu.startswith('0000:') else gpu
                driver_path = Path(f'/sys/bus/pci/devices/{pci_addr}/driver')
                driver = driver_path.resolve().name if driver_path.exists() else 'none'
                try:
                    cc_mode = query_cc_mode(pci_addr)
                    print(f'  {pci_addr} (driver: {driver}, CC mode: {cc_mode})')
                except SystemExit:
                    # CC mode query failed, just show driver
                    print(f'  {pci_addr} (driver: {driver}, CC mode: unknown)')
            print('=================================')
        else:
            print('No NVIDIA GPUs found')
        
        print('\nUsage: setup-gpu-vfio [--setup|--restore] <pci-address>')
        print('Examples:')
        print('  setup-gpu-vfio 0000:ab:00.00              # Verify GPU state')
        print('  setup-gpu-vfio --setup 0000:ab:00.00      # Configure for VFIO')
        print('  setup-gpu-vfio --restore 0000:ab:00.00    # Restore to normal')
        print('\nEnvironment overrides:')
        print('  GPU_ADMIN_TOOLS_DIR=/path/to/gpu-admin-tools')
        print('  VFIO_DEVICE_GROUP=<existing-group-for-vfio>')
        sys.exit(0 if gpus else 1)
    
    mode = 'verify'
    pci_addr = sys.argv[1]
    
    if sys.argv[1] in ('--setup', '--restore'):
        if len(sys.argv) != 3:
            sys.exit(f'ERROR: PCI address required after {sys.argv[1]}')
        mode = sys.argv[1][2:]  # Remove '--' prefix
        pci_addr = sys.argv[2]
    
    if mode == 'restore':
        restore_gpu(pci_addr)
    elif mode == 'setup':
        setup_gpu(pci_addr)
    else:  # verify
        verify_gpu(pci_addr)

if __name__ == '__main__':
    main()
