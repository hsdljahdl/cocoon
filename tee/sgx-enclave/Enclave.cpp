// SGX enclave: verify TDX report, derive sealed key, ECDH, return encrypted secret in report

#include "Enclave_t.h"  // Auto-generated by edger8r
#include <sgx_tcrypto.h>
#include <sgx_tseal.h>
#include <sgx_utils.h>  // sgx_verify_report2()
#include <tlibc/stdarg.h>
#include <tlibc/stdio.h>
#include <tlibc/string.h>

// Constants for cryptographic operations
static constexpr size_t PRINTF_BUFFER_SIZE = 256;
static constexpr size_t AES_KEY_SIZE = 16;
static constexpr size_t SHA256_SIZE = 32;
static constexpr size_t SHA384_SIZE = 48;

static_assert(sizeof(sgx_ec256_public_t) == 64, "sgx_ec256_public_t must be 64 bytes (X||Y)");
static_assert(SGX_SHA256_HASH_SIZE == 32, "SHA-256 size must be 32 bytes");
static_assert(SGX_SHA384_HASH_SIZE == 48, "SHA-384 size must be 48 bytes");

// TDX report type constants
static constexpr uint8_t EXPECTED_REPORT_TYPE = 0x81;
static constexpr uint8_t EXPECTED_REPORT_SUBTYPE = 0;
static constexpr uint8_t EXPECTED_REPORT_VERSION = 0;
static constexpr uint8_t EXPECTED_REPORT_RESERVED = 0;

void enclave_printf(const char *fmt, ...) __attribute__((format(printf, 1, 2)));

void enclave_printf(const char *fmt, ...) {
  char buffer[PRINTF_BUFFER_SIZE];
  va_list args;
  va_start(args, fmt);
  vsnprintf(buffer, sizeof(buffer), fmt, args);
  va_end(args);
  ocall_print(buffer);
}

#define SGX_TRY(cmd, fmt, ...)            \
  {                                       \
    sgx_status_t status = (cmd);          \
    if (status != SGX_SUCCESS) {          \
      enclave_printf((fmt), __VA_ARGS__); \
      return status;                      \
    }                                     \
  }

#define CONCAT_IMPL(x, y) x##y
#define CONCAT(x, y) CONCAT_IMPL(x, y)
#define UNIQUE_NAME(base) CONCAT(base, __COUNTER__)
#define SCOPE_EXIT auto UNIQUE_NAME(_scope_exit_) = ScopeExitHelper() + [&]()

struct ScopeExitHelper {
  template <class F>
  struct ScopeExit {
    F f;
    ~ScopeExit() {
      f();
    }
  };
  template <class F>
  ScopeExit<F> operator+(F f) {
    return {f};
  }
};

// Simple hex dump utility for debugging
static void hex_dump(const char *label, const void *data, size_t size) {
  const auto *bytes = static_cast<const uint8_t *>(data);
  char buf[512];
  int offset = 0;

  for (size_t i = 0; i < size && offset < sizeof(buf) - 3; i++) {
    offset += snprintf(buf + offset, sizeof(buf) - offset, "%02x", bytes[i]);
  }

  enclave_printf("%s (%zu bytes): %s", label, size, buf);
}

sgx_status_t get_cpusvn(sgx_cpu_svn_t *out_cpusvn) {
  sgx_report_t rep = {0};
  sgx_status_t st = sgx_create_report(NULL, NULL, &rep);
  if (st != SGX_SUCCESS) {
    return st;
  }

  // rep.body.cpu_svn is 16 bytes
  memcpy(out_cpusvn, &rep.body.cpu_svn, sizeof(rep.body.cpu_svn));
  return SGX_SUCCESS;
}

static inline void secure_zero(void *ptr, size_t size) {
  (void)memset_s(ptr, size, 0, size);
}

/**
 * SGX enclave entry point for key generation.
 *
 * This function:
 * 1. Validates the TDX report
 * 2. Derives a persistent key using SGX sealing
 * 3. Performs ECDH key exchange with the client
 * 4. Encrypts the persistent key using AES-128-CTR
 * 5. Creates an SGX report with the encrypted data
 *
 * @param sgx_target_info Target info for SGX report generation
 * @param tdx_report TDX report from the client
 * @param public_key Client's EC public key for ECDH
 * @param public_key_size Size of the public key
 * @param encrypted_secret_buf Buffer for the encrypted secret
 * @param encrypted_secret_buf_size Size of the buffer
 * @param encrypted_secret_size Actual size of the encrypted secret
 * @param sgx_report Generated SGX report
 * @return SGX status code
 */
extern "C" sgx_status_t ecall_gen_key(const sgx_target_info_t *sgx_target_info, const sgx_report2_t *tdx_report,
                                      const char *public_key, size_t public_key_size, const char *key_name,
                                      size_t key_name_size, char *encrypted_secret_buf,
                                      size_t encrypted_secret_buf_size, size_t *encrypted_secret_size,
                                      sgx_report_t *sgx_report) {
  enclave_printf("ecall_gen_key: start");

  // Basic parameter validation
  if (sgx_target_info == nullptr || tdx_report == nullptr || public_key == nullptr || key_name == nullptr ||
      encrypted_secret_buf == nullptr || encrypted_secret_size == nullptr || sgx_report == nullptr) {
    enclave_printf("Invalid null pointer in arguments");
    return SGX_ERROR_INVALID_PARAMETER;
  }

  // Validate key name size
  if (key_name_size == 0 || key_name_size > 256) {
    enclave_printf("Invalid key name size: %zu (must be 1-256)", key_name_size);
    return SGX_ERROR_INVALID_PARAMETER;
  }

  // Validate and extract peer public key
  sgx_ec256_public_t peer_public_key;
  if (sizeof(peer_public_key) != public_key_size) {
    enclave_printf("Invalid public key size: got %zu, expected %zu", public_key_size, sizeof(peer_public_key));
    return SGX_ERROR_INVALID_PARAMETER;
  }
  memcpy(&peer_public_key, public_key, public_key_size);

  // Validate TDX report type
  const auto &report_type = tdx_report->report_mac_struct.report_type;
  if (report_type.type != EXPECTED_REPORT_TYPE || report_type.subtype != EXPECTED_REPORT_SUBTYPE ||
      report_type.version != EXPECTED_REPORT_VERSION || report_type.reserved != EXPECTED_REPORT_RESERVED) {
    enclave_printf("Invalid TDX report type: type=0x%x subtype=%d version=%d reserved=%d", int(report_type.type),
                   int(report_type.subtype), int(report_type.version), int(report_type.reserved));
    return SGX_ERROR_INVALID_PARAMETER;
  }

  sgx_sha256_hash_t public_key_hash;
  SGX_TRY(sgx_sha256_msg(reinterpret_cast<const uint8_t *>(public_key), public_key_size, &public_key_hash),
          "Failed to hash public key: 0x%x", int(status));

  sgx_report_data_t expected_tdx_report_data = {};
  memcpy(expected_tdx_report_data.d, public_key_hash, SHA256_SIZE);
  if (memcmp(expected_tdx_report_data.d, tdx_report->report_mac_struct.report_data.d, SGX_REPORT_DATA_SIZE) != 0) {
    enclave_printf("TDX report data mismatch:");
    enclave_printf("Expected: ");
    hex_dump("TDX report data", expected_tdx_report_data.d, SGX_REPORT_DATA_SIZE);
    enclave_printf("Actual: ");
    hex_dump("TDX report data", tdx_report->report_mac_struct.report_data.d, SGX_REPORT_DATA_SIZE);
    return SGX_ERROR_INVALID_PARAMETER;
  }

  sgx_cpu_svn_t expected_cpusvn = {};
  SGX_TRY(get_cpusvn(&expected_cpusvn), "Failed to get CPU SVN: 0x%x", int(status));
  hex_dump("EXP CPU SVN", &expected_cpusvn, sizeof(expected_cpusvn));
  hex_dump("GOT CPU SVN", &tdx_report->report_mac_struct.cpu_svn, sizeof(tdx_report->report_mac_struct.cpu_svn));
  SGX_TRY(sgx_verify_report2(&tdx_report->report_mac_struct), "TDX report verification failed: 0x%x", int(status));

  enclave_printf("TDX report validation successful");

  // Derive sealing key (specific to this enclave's hash)
  sgx_key_request_t key_request = {};
  key_request.key_name = SGX_KEYSELECT_SEAL;
  key_request.key_policy = SGX_KEYPOLICY_MRSIGNER;

  sgx_key_128bit_t sealing_key;
  SGX_TRY(sgx_get_key(&key_request, &sealing_key), "Failed to derive sealing key: 0x%x", int(status));

  enclave_printf("Sealing key derived");

  SCOPE_EXIT {
    secure_zero(sealing_key, sizeof(sealing_key));
  };

  // Derive persistent key by combining sealing key with TDX measurements
  sgx_sha_state_handle_t sha_context = {};
  SGX_TRY(sgx_sha256_init(&sha_context), "SHA256 initialization failed: 0x%x", int(status));

  SCOPE_EXIT {
    sgx_sha256_close(sha_context);
  };

  // Hash sealing key
  SGX_TRY(sgx_sha256_update(sealing_key, AES_KEY_SIZE, sha_context), "Failed to hash sealing key: 0x%x", int(status));

  // Hash TEE info (binds key to specific TDX configuration)
  SGX_TRY(sgx_sha256_update(tdx_report->report_mac_struct.tee_info_hash.m, SHA384_SIZE, sha_context),
          "Failed to hash TEE info: 0x%x", int(status));

  // Hash TEE TCB info (binds key to specific TDX TCB level)
  SGX_TRY(sgx_sha256_update(tdx_report->report_mac_struct.tee_tcb_info_hash.m, SHA384_SIZE, sha_context),
          "Failed to hash TEE TCB info: 0x%x", int(status));

  // Hash key name (derives specific key for the given purpose)
  sgx_sha256_hash_t key_name_hash;
  SGX_TRY(sgx_sha256_msg(reinterpret_cast<const uint8_t *>(key_name), (int)key_name_size, &key_name_hash),
          "Failed to hash key name: 0x%x", int(status));
  SGX_TRY(sgx_sha256_update(key_name_hash, SHA256_SIZE, sha_context), "Failed to update with key name hash: 0x%x",
          int(status));

  sgx_sha256_hash_t persistent_key;
  SGX_TRY(sgx_sha256_get_hash(sha_context, &persistent_key), "Failed to finalize persistent key hash: 0x%x",
          int(status));

  enclave_printf("Persistent key derived with key name: %.*s", (int)key_name_size, key_name);

  enclave_printf("Persistent key derived");

  SCOPE_EXIT {
    secure_zero(persistent_key, sizeof(persistent_key));
  };

  // Prepare for key encryption: [enclave_pubkey (64)] [ciphertext (32)]
  *encrypted_secret_size = sizeof(sgx_ec256_public_t) + sizeof(persistent_key);
  if (encrypted_secret_buf_size < *encrypted_secret_size) {
    enclave_printf("Encrypted secret buffer too small: need %zu, got %zu", *encrypted_secret_size,
                   encrypted_secret_buf_size);
    return SGX_ERROR_INVALID_PARAMETER;
  }

  // Generate ephemeral EC key pair for ECDH
  sgx_ecc_state_handle_t ecc_context = nullptr;
  SGX_TRY(sgx_ecc256_open_context(&ecc_context), "Failed to open ECC context: 0x%x", int(status));

  SCOPE_EXIT {
    if (ecc_context) {
      sgx_ecc256_close_context(ecc_context);
    }
  };

  sgx_ec256_private_t enclave_private_key;
  sgx_ec256_public_t enclave_public_key;
  SGX_TRY(sgx_ecc256_create_key_pair(&enclave_private_key, &enclave_public_key, ecc_context),
          "Failed to generate EC key pair: 0x%x", int(status));

  enclave_printf("ECDH key pair generated");

  // Perform ECDH key exchange
  sgx_ec256_dh_shared_t shared_secret;
  SGX_TRY(sgx_ecc256_compute_shared_dhkey(&enclave_private_key, &peer_public_key, &shared_secret, ecc_context),
          "ECDH key exchange failed: 0x%x", int(status));
  // Ensure ephemeral private key will not linger in memory
  SCOPE_EXIT {
    secure_zero(&enclave_private_key, sizeof(enclave_private_key));
  };
  SCOPE_EXIT {
    secure_zero(&shared_secret, sizeof(shared_secret));
  };

  enclave_printf("ECDH OK");

  // Encrypt the persistent key using AES-128-CTR
  // Derive key and IV from SHA-256(shared_secret)
  sgx_sha256_hash_t key_iv_hash;
  SGX_TRY(sgx_sha256_msg(shared_secret.s, sizeof(shared_secret.s), &key_iv_hash), "SHA256(shared_secret) failed: 0x%x",
          int(status));
  sgx_aes_ctr_128bit_key_t aes_key;
  memcpy(aes_key, key_iv_hash, AES_KEY_SIZE);
  uint8_t iv[16];
  memcpy(iv, key_iv_hash + AES_KEY_SIZE, 16);
  SCOPE_EXIT {
    secure_zero(aes_key, sizeof(aes_key));
    secure_zero(iv, sizeof(iv));
    secure_zero(key_iv_hash, sizeof(key_iv_hash));
  };

  // Store enclave public key at the beginning of the buffer
  memcpy(encrypted_secret_buf, &enclave_public_key, sizeof(enclave_public_key));

  // Encrypt the persistent key
  SGX_TRY(sgx_aes_ctr_encrypt(&aes_key, persistent_key, sizeof(persistent_key), iv, 128,
                              reinterpret_cast<uint8_t *>(encrypted_secret_buf + sizeof(enclave_public_key))),
          "AES encryption failed: 0x%x", int(status));

  enclave_printf("Secret encrypted");

  // Create report data with hashes of public key and encrypted secret
  sgx_report_data_t sgx_report_data = {};

  sgx_sha256_hash_t encrypted_secret_hash;
  SGX_TRY(sgx_sha256_msg(reinterpret_cast<const uint8_t *>(encrypted_secret_buf), *encrypted_secret_size,
                         &encrypted_secret_hash),
          "Failed to hash encrypted secret: 0x%x", int(status));

  // Pack hashes into report data (64 bytes total)
  static_assert(sizeof(sgx_report_data.d) == 64, "Report data must be 64 bytes");
  static_assert(sizeof(public_key_hash) == SHA256_SIZE, "SHA256 hash must be 32 bytes");
  static_assert(sizeof(encrypted_secret_hash) == SHA256_SIZE, "SHA256 hash must be 32 bytes");

  // sgx_sha256_hash_t is typedef'd as uint8_t[32]; use array-decay form when copying
  memcpy(sgx_report_data.d, public_key_hash, SHA256_SIZE);
  memcpy(sgx_report_data.d + SHA256_SIZE, encrypted_secret_hash, SHA256_SIZE);

  // Generate SGX report
  SGX_TRY(sgx_create_report(sgx_target_info, &sgx_report_data, sgx_report), "Failed to create SGX report: 0x%x",
          int(status));

  enclave_printf("SGX report created");

  return SGX_SUCCESS;
}
